{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "ADF-Neill"
		},
		"datalakestoragenk_accountKey": {
			"type": "secureString",
			"metadata": "Secure string for 'accountKey' of 'datalakestoragenk'"
		},
		"datalakestoragenk_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://datalakestoragenk.dfs.core.windows.net/"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/Transform_Movies')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "TransformMovies",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "TransformMovies",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"MoviesDB": {},
									"MoviesSink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "None",
							"cacheSinks": {
								"firstRowOnly": true
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/TransformMovies')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_pipeline2')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Wait1",
						"type": "Wait",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 5
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_wait')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Wait1",
						"type": "Wait",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 1
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/MoviesDB')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakestoragenk",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "MoviesDB.csv",
						"folderPath": "data",
						"fileSystem": "testcontainer"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "movie",
						"type": "String"
					},
					{
						"name": "title",
						"type": "String"
					},
					{
						"name": "genres",
						"type": "String"
					},
					{
						"name": "year",
						"type": "String"
					},
					{
						"name": "Rating",
						"type": "String"
					},
					{
						"name": "RottenTomato",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakestoragenk')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/MoviesSink')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakestoragenk",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "output",
						"fileSystem": "testcontainer"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakestoragenk')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/datalakestoragenk')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('datalakestoragenk_properties_typeProperties_url')]",
					"accountKey": {
						"type": "SecureString",
						"value": "[parameters('datalakestoragenk_accountKey')]"
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TransformMovies')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "MoviesDB",
								"type": "DatasetReference"
							},
							"name": "MoviesDB"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "MoviesSink",
								"type": "DatasetReference"
							},
							"name": "MoviesSink",
							"rejectedDataLinkedService": {
								"referenceName": "datalakestoragenk",
								"type": "LinkedServiceReference"
							}
						}
					],
					"transformations": [
						{
							"name": "filter1"
						},
						{
							"name": "AggregateComedyRating"
						}
					],
					"scriptLines": [
						"source(output(",
						"          movie as string,",
						"          title as string,",
						"          genres as string,",
						"          year as string,",
						"          Rating as string,",
						"          RottenTomato as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> MoviesDB",
						"MoviesDB filter(toInteger(year) >= 1910 && toInteger(year) <= 2000 && rlike(genres, 'Comedy')) ~> filter1",
						"filter1 aggregate(groupBy(year),",
						"     AggregateComedyRating = avg(toInteger(Rating))) ~> AggregateComedyRating",
						"AggregateComedyRating sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['MoviesDB Average Ratings'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          year,",
						"          AggregateComedyRating",
						"     ),",
						"     partitionBy('hash', 1)) ~> MoviesSink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/MoviesDB')]",
				"[concat(variables('factoryId'), '/datasets/MoviesSink')]",
				"[concat(variables('factoryId'), '/linkedServices/datalakestoragenk')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "MoviesDB",
								"type": "DatasetReference"
							},
							"name": "Movies"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "MoviesSink",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "MoreAggs"
						},
						{
							"name": "SelectCopy"
						},
						{
							"name": "ValueDistAgg"
						},
						{
							"name": "UniqDist"
						},
						{
							"name": "SummaryStats"
						},
						{
							"name": "Join1"
						},
						{
							"name": "DerivedColumn1"
						},
						{
							"name": "alterRow1"
						},
						{
							"name": "RowCount"
						},
						{
							"name": "DistinctRows"
						},
						{
							"name": "LookForNULLs"
						},
						{
							"name": "DerivedColumn"
						},
						{
							"name": "SurrogateKey"
						},
						{
							"name": "Window1"
						},
						{
							"name": "KeyPatternDistinctCountAllCol"
						},
						{
							"name": "SurrogateKey1"
						},
						{
							"name": "DerivedColumn3"
						},
						{
							"name": "leadAndLag"
						}
					],
					"scriptLines": [
						"source(output(",
						"          movie as string,",
						"          title as string,",
						"          genres as string,",
						"          year as string,",
						"          Rating as string,",
						"          RottenTomato as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> Movies",
						"Movies select(mapColumn(",
						"          movie,",
						"          title,",
						"          genres,",
						"          year,",
						"          Rating,",
						"          RottenTomato",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> MoreAggs",
						"MoreAggs select(mapColumn(",
						"          movie,",
						"          title,",
						"          genres,",
						"          year,",
						"          Rating,",
						"          RottenTomato",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectCopy",
						"SelectCopy aggregate(groupBy(title),",
						"     countunique = count()) ~> ValueDistAgg",
						"ValueDistAgg aggregate(numofunique = countIf(countunique==1),",
						"          numofdistinct = countDistinct(title)) ~> UniqDist",
						"Movies aggregate(each(match(true()), $$+'_NotNull' = countIf(!isNull($$)), $$+'_Null' = countIf(!isNull($$))),",
						"          each(match(type=='double'||type=='integer'||type=='short'||type=='decimal'), $$+'_stddev' = round(stddev($$),2), $$+'_min' = min($$), $$+'_max' = max($$), $$+'_average' = round(avg($$),2), $$+'_variance' = round(variance($$),2)),",
						"          each(match(type=='string'), $$+'_maxLength' = max(length($$)))) ~> SummaryStats",
						"SummaryStats, UniqDist join((movie_NotNull-movie_NotNull) == (numofunique-numofunique),",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> Join1",
						"UniqDist derive(DWhash = sha1(numofunique,numofdistinct)) ~> DerivedColumn1",
						"Movies alterRow(upsertIf(true())) ~> alterRow1",
						"alterRow1 aggregate(updates = countIf(isUpdate(), 1),",
						"          inserts = countIf(isInsert(), 1),",
						"          upserts = countIf(isUpsert(), 1),",
						"          deletes = countIf(isDelete(),1)) ~> RowCount",
						"Movies aggregate(groupBy(mycols = sha2(256,columns())),",
						"     each(match(true()), $$ = first($$))) ~> DistinctRows",
						"Movies split(contains(array(toString(columns())),isNull(#item)),",
						"     disjoint: false) ~> LookForNULLs@(hasNULLs, noNULLs)",
						"Movies derive(dummy = 1) ~> DerivedColumn",
						"DerivedColumn keyGenerate(output(sk as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> SurrogateKey",
						"SurrogateKey window(over(dummy),",
						"     asc(sk, true),",
						"     Rating2 = coalesce(Rating, last(Rating, true()))) ~> Window1",
						"Window1 aggregate(each(match(true()), $$ = countDistinct($$))) ~> KeyPatternDistinctCountAllCol",
						"Window1 keyGenerate(output(sk as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> SurrogateKey1",
						"SurrogateKey1 derive(dummy = 1) ~> DerivedColumn3",
						"DerivedColumn3 window(over(dummy),",
						"     asc(sk, true),",
						"     prevAndCurr = lag(title,1)+'-'+last(title),",
						"          nextAndCurr = lead(title,1)+'-'+last(title)) ~> leadAndLag",
						"leadAndLag sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/MoviesDB')]",
				"[concat(variables('factoryId'), '/datasets/MoviesSink')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_dedupe')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "MoviesDB",
								"type": "DatasetReference"
							},
							"name": "Movies"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "MoviesSink",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "DistinctRows"
						},
						{
							"name": "OrignalData"
						},
						{
							"name": "DistinctAllCols"
						},
						{
							"name": "FuzzyMatch"
						},
						{
							"name": "RowCountFuzzy"
						},
						{
							"name": "RowCountAll"
						},
						{
							"name": "RowCountOrig"
						},
						{
							"name": "RowCountDistinct"
						}
					],
					"scriptLines": [
						"source(output(",
						"          movie as string,",
						"          title as string,",
						"          genres as string,",
						"          year as string,",
						"          Rating as string,",
						"          RottenTomato as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> Movies",
						"Movies aggregate(groupBy(movie),",
						"     each(match(name!='movie'), $$ = first($$))) ~> DistinctRows",
						"Movies select(mapColumn(",
						"          movie,",
						"          title,",
						"          genres,",
						"          year,",
						"          Rating,",
						"          RottenTomato",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> OrignalData",
						"Movies aggregate(groupBy(mycols = sha2(256, columns())),",
						"     each(match(true()), $$ = first($$))) ~> DistinctAllCols",
						"Movies aggregate(groupBy(colsfuzzy = sha2(256,movie,year,soundex(title))),",
						"     each(match(true()), $$ = first($$))) ~> FuzzyMatch",
						"FuzzyMatch aggregate(rowcount_fuzzy = count(1)) ~> RowCountFuzzy",
						"DistinctAllCols aggregate(rowcount_all = count(1)) ~> RowCountAll",
						"OrignalData aggregate(rowcount_orig = count(1)) ~> RowCountOrig",
						"DistinctRows aggregate(rowcount_agg = count(1)) ~> RowCountDistinct",
						"DistinctRows sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/MoviesDB')]",
				"[concat(variables('factoryId'), '/datasets/MoviesSink')]"
			]
		}
	]
}